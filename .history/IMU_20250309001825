#include <avr/io.h>
#include "init_290.c"
#include <stdio.h>
#include <avr/delay.h>
#include "TWI_290.c"

//defining registers address
#define ACCEL_CONFIG 0x1C
#define GYRO_CONFIG 0x1B
#define I2C_ADDRESS 0x68

//defininf gyro output registers for read
#define GYRO_XOUT_H 0x43
#define GYRO_XOUT_L 0x44
#define GYRO_YOUT_H 0x45
#define GYRO_YOUT_L 0x46
#define GYRO_ZOUT_H 0x47
#define GYRO_ZOUT_L 0x48

// defining accel output registers for read
#define ACCEL_XOUT_H 0x3B
#define ACCEL_XOUT_L 0x3C
#define ACCEL_YOUT_H 0x3D
#define ACCEL_YOUT_L 0x3E
#define ACCEL_ZOUT_H 0x3F
#define ACCEL_ZOUT_L 0x40

int32_t zOffset, yOffset, xOffset;

//UART start transmission function
void send_reading(char data) {
  while (!(UCSR0A & (1 << UDRE0))); // Wait until the buffer is empty
  UDR0 = data; // Send received char to UDR0 (Data register)
}

// send string to transmission function
void send_string(const char* str) { // send string to send function
  while (*str) { // while string not empty
    send_reading(*str++); //send string to send_Readin
  }
}

void MPU6050_init(void) {
  TWI_status = TWI_start(I2C_ADDRESS, TW_WRITE);
  if (TWI_status) return;

  TWI_status = TWI_write(0x6B);
  if (TWI_status) return;

  TWI_status = TWI_write(0x00);
  if (TWI_status) return;

  TWI_stop();
}

int16_t x_gyro, y_gyro, z_gyro;
int16_t x_accel, y_accel, z_accel;

void Read_Gyro_Data() {
  uint16_t x_gyro_data[2], y_gyro_data[2], z_gyro_data[2];

  // Read X-axis

  Read_Reg_N(I2C_ADDRESS, GYRO_XOUT_H, 2, x_gyro_data);
  x_gyro = (x_gyro_data[0] << 8) | x_gyro_data[1];

  // Read Y-axis

  Read_Reg_N(I2C_ADDRESS, GYRO_YOUT_H, 2, y_gyro_data);
  y_gyro = (y_gyro_data[0] << 8) | y_gyro_data[1];

  // Read Z-axis
  Read_Reg_N(I2C_ADDRESS, GYRO_ZOUT_H, 2, z_gyro_data);
  z_gyro = (z_gyro_data[0] << 8) | z_gyro_data[1];

  // char buffer[50];
  // sprintf(buffer, "X: %d, Y: %d, Z: %d\n", x_gyro, y_gyro, z_gyro);
  // send_string(buffer);  // Print all gyro readings for debugging
}

//Reading Accelerometer Data held in the accel config register
void Read_Accel_Data() {
  //read x-axis
  int16_t x_accel_data[2]; //array holding low and high bytes of gyro register
  Read_Reg_N(ACCEL_CONFIG, ACCEL_XOUT_H, 2, x_accel_data); //read starting from H and store to array
  x_accel = (x_accel_data[0] << 8) | (x_accel_data[1] & 0xFF); // shift by 8 bits x_gyro_data (1byte) -> MSB and combine with the other byte

  //y
  int16_t y_accel_data[2];
  Read_Reg_N(ACCEL_CONFIG, ACCEL_YOUT_H, 2, y_accel_data);
  y_accel = (y_accel_data[0] << 8) | (y_accel_data[1] & 0xFF);


  //z
  int16_t z_accel_data[2];
  Read_Reg_N(ACCEL_CONFIG, ACCEL_ZOUT_H, 2, z_accel_data);
  z_accel = (z_accel_data[0] << 8) | (z_accel_data[1] & 0xFF);

  //Note: &FF to ensure it's reading 8 bits, avoid sign extensions
}

float yaw = 0;
float prev_yaw = 0;
bool right, left;

float Calculate_Yaw() {
  float z_gyro_rate = (z_gyro / 65.5); // Assuming ±500 deg/s scale

  if ((z_gyro_rate < 1.2) && (z_gyro_rate > -1.2)) {
    z_gyro_rate = 0;
  }
  
  yaw = prev_yaw + ((z_gyro_rate) * 0.02); // Integrate over 20ms (50Hz)
  prev_yaw = yaw;

  return yaw;
}

void set_servo_position(float yaw) {

  //map yaw to values in range[0,255]
  yaw *= 1.1;
  if(yaw < -90) yaw = -90;
  if(yaw > 90) yaw = 90;
  
  uint16_t position = (yaw+90) / 180 * 255;

  //set PWM to value
  OCR1A = Servo_angle[position];
}

void caliberateGyro(){
  zOffset = 0;
  yOffset = 0;
  xOffset = 0;
  for (int m = 0; m < 500; m++) {
    Read_Gyro_Data();
    zOffset += (z_gyro);
    yOffset += (y_gyro);
    xOffset += (x_gyro);
    _delay_ms(10);
  }
  zOffset /= 500;
  yOffset /= 500;
  xOffset /= 500;
}


int main(void) 
{
  //gpio_init();
  uart_init();
  twi_init();
  MPU6050_init();

  Write_Reg(I2C_ADDRESS, 0x6B, 0x00); // Wake up MPU6050
  Write_Reg(I2C_ADDRESS, ACCEL_CONFIG, 0x00); // ±2g range
  Write_Reg(I2C_ADDRESS, GYRO_CONFIG, 0x00);  // ±500 deg/s range

  Serial.println("Start calibration");
  caliberateGyro();
    while (1){
    // read IMU
    Read_Gyro_Data();
    Serial.println(z_gyro);

    yaw = Calculate_Yaw();
    if(right){
      yaw += 90;
      if(yaw > 90) 
        yaw = 90;
    }
    if(left){
      yaw -= 90;
      if(yaw < -90) 
        yaw = -90;
    }

    //z_gyro -= zOffset;
    y_gyro -= yOffset;
    x_gyro -= xOffset;

    // Serial.print("Z_Gryo: ");
    // Serial.print(z_gyro);
    // Serial.print(" Y_Gryo: ");
    // Serial.print(y_gyro);
    // Serial.print(" X_Gryo: ");
    // Serial.println(x_gyro);

    _delay_ms(25);
  }

  return 0;  // End program
}

void testIMU() {
  // Simulated accelerometer, gyroscope, and magnetometer data
  float simulatedAccel[] = {0.1, 0.2, 9.81};
  float simulatedGyro[] = {0.01, 0.01, 0.1};
  float simulatedMag[] = {0.1, 0.2, 0.3};

  // Call the function that would normally process your IMU data
  processIMUData(simulatedAccel, simulatedGyro, simulatedMag);
}

void processIMUData(float accel[], float gyro[], float mag[]) {
  // Just printing to demonstrate data flow
  Serial.print("Processed Accel: ");
  Serial.print(accel[0]);
  Serial.print(", ");
  Serial.print(accel[1]);
  Serial.print(", ");
  Serial.println(accel[2]);

  Serial.print("Processed Gyro: ");
  Serial.print(gyro[0]);
  Serial.print(", ");
  Serial.print(gyro[1]);
  Serial.print(", ");
  Serial.println(gyro[2]);

  Serial.print("Processed Mag: ");
  Serial.print(mag[0]);
  Serial.print(", ");
  Serial.print(mag[1]);
  Serial.print(", ");
  Serial.println(mag[2]);
}

void setup() {
  Serial.begin(9600);
  testIMU();  // Run the test function
}

void loop() {
  // Your main loop logic
}
